<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>算法 - 分类 - Kwebi&#39;s blog</title>
        <link>http://localhost:1313/categories/%E7%AE%97%E6%B3%95/</link>
        <description>算法 - 分类 - Kwebi&#39;s blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 04 Oct 2019 21:31:35 &#43;0000</lastBuildDate><atom:link href="http://localhost:1313/categories/%E7%AE%97%E6%B3%95/" rel="self" type="application/rss+xml" /><item>
    <title>gym101177I-最长上升子序列</title>
    <link>http://localhost:1313/gym101177i-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</link>
    <pubDate>Fri, 04 Oct 2019 21:31:35 &#43;0000</pubDate>
    <author>kwebi</author>
    <guid>http://localhost:1313/gym101177i-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
    <description><![CDATA[<p>题目大意是给你一系列区间，区间两两互不相交，但可能会有重复出现，区间的值等于区间的长度，求最大的上升的区间值和。你可以类比最长上升子序列，不过最长上升子序列求的是序列的长度，而这里转化为序列的值。
</p>]]></description>
</item>
<item>
    <title>快速幂与模运算</title>
    <link>http://localhost:1313/%E5%BF%AB%E9%80%9F%E5%B9%82%E4%B8%8E%E6%A8%A1%E8%BF%90%E7%AE%97/</link>
    <pubDate>Wed, 15 May 2019 17:21:41 &#43;0000</pubDate>
    <author>kwebi</author>
    <guid>http://localhost:1313/%E5%BF%AB%E9%80%9F%E5%B9%82%E4%B8%8E%E6%A8%A1%E8%BF%90%E7%AE%97/</guid>
    <description><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1226" target="_blank" rel="noopener noreffer ">例题</a>:</p>
<blockquote>
<p>输入 <code>b</code>，<code>p</code>，<code>k</code> 的值，求 <code>b</code>^<code>p</code> mod <code>k</code> 的值。其中 <code>b</code>，<code>p</code>，<code>k</code> 为长整型数。</p>
</blockquote>]]></description>
</item>
<item>
    <title>最小生成树算法</title>
    <link>http://localhost:1313/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/</link>
    <pubDate>Sat, 04 May 2019 13:49:31 &#43;0000</pubDate>
    <author>kwebi</author>
    <guid>http://localhost:1313/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/</guid>
    <description><![CDATA[<h3 id="1-prim算法">(1) Prim算法</h3>
<p>取图中任意一个顶点 v 作为生成树的根，之后往生成树上添加新的顶点 w。在添加的顶点 w 和已经在生成树上的顶点v 之间必定存在一条边，并且该边的权值在所有连通顶点 v 和 w 之间的边中取值最小。之后继续往生成树上添加顶点，直至生成树上含有 n 个顶点为止。</p>]]></description>
</item>
<item>
    <title>优先队列的应用C&#43;&#43;实现</title>
    <link>http://localhost:1313/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8c-%E5%AE%9E%E7%8E%B0/</link>
    <pubDate>Tue, 30 Oct 2018 22:53:04 &#43;0000</pubDate>
    <author>kwebi</author>
    <guid>http://localhost:1313/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8c-%E5%AE%9E%E7%8E%B0/</guid>
    <description><![CDATA[<p>优先队列可以用堆来实现, 堆底层可以用数组表示，
通过索引关系，可以表示成一颗二叉完全树</p>]]></description>
</item>
</channel>
</rss>
